import sys,argparse
import csv
import random

def read_options(filename):
    """Generates a list of options by reading the given csv file."""
    with open(filename) as src_file:
        csv_reader = csv.reader(src_file,delimiter=',')
        return [' '.join(row) for row in csv_reader]

def generate_categories(names=[],places=[]):
    """Contains default lists for each of the categories. If provided,
        will also add names and places from the associated files."""
    categories = {
            'title': [],
            'occupations': [],
            'cool_words': [],
            'creatures': [],
            'names': names,
            'places': places,
            'of': ['of'] ,
            'comma': [','],
            'nothing': ['']
            }
    categories['title'] += [
            'Slayer','Bane','Lord','Blight','Fiend','Foe','Shaker','Baron','King']
    categories['occupations'] += [
            'Slayer','Shaker','Bringer','Caster','Thrower','Slinger','Destroyer','Crusher','Killer','Eater','Smasher']
    categories['cool_words'] += [
            'Earth','Storm','Thunder','Ice','Fire','Flame','Death','Blood','Skull','Metal','Frost','Shadow','Evil']
    categories['creatures'] += [
            'Spider','Goblin','Dwarf','Elf','Serpent','Dragon','Raven','Wolf','Demon','Devil','Spirit']
    categories['names'] += [
            'John','Erik','Eugene','Jim']
    categories['places'] += [
            'Boulder','Denver','Fort Collins','the Springs']

    weights = {}
    for key_base in categories:
        weights[key_base] = {}
        for key in categories:
            weights[key_base][key] = 0

    # 0 title
    # 1 occupations
    # 2 cool words
    # 3 creatures
    # 4 names
    # 5 places
    # 6 of
    # 7 comma
    # 8 nothing

    weights['title']['of'] = 0.5
    weights['title']['nothing'] = 0.5

    weights['occupations']['of'] = 0.3
    weights['occupations']['nothing'] = 0.7

    weights['cool_words']['title'] = 0.2
    weights['cool_words']['occupations'] = 0.5
    weights['cool_words']['cool_words'] = 0.1
    weights['cool_words']['creatures'] = 0.2

    weights['creatures']['title'] = 0.6
    weights['creatures']['occupations'] = 0.3
    weights['creatures']['creatures'] = 0.1

    weights['names']['comma'] = 0.5
    weights['names']['of'] = 0.5

    weights['places']['comma'] = 0.3
    weights['places']['nothing'] = 0.7

    weights['of']['places'] = 0.9
    weights['of']['creatures'] = 0.05
    weights['of']['cool_words'] = 0.05

    weights['comma']['title'] = 0.3
    weights['comma']['occupations'] = 0.3
    weights['comma']['cool_words'] = 0.2
    weights['comma']['creatures'] = 0.2

    weights['nothing']['nothing'] = 1


    # normalize weights
    for cat,sub_dict in weights.items():
        total = sum(sub_dict.values())
        if total != 1:
            for k,v in sub_dict.items():
                weights[cat][k] = v/total

    return categories,weights


def generate_name(chain,categories):
    """Takes in a chain as generated by transition and makes a name."""
    name = random.choice(categories[chain[0]])
    for state in chain[1:]:
        if state == 'nothing':
            break
        else:
            if state == 'comma':
                name += random.choice(categories[state])
            else:
                name += ' ' + random.choice(categories[state])

    return name

def transition(chain,weights):
    """Creates a chain recursively using the transition matrix defined by weights."""
    curr_state = chain[-1]
    if curr_state == 'nothing' or weights[curr_state][curr_state]==1:
        return chain

    next_state_index = random.random()
    for k,v in weights[curr_state].items():
        if next_state_index - v < 0:
            chain.append(k)
            return transition(chain,weights)
        else:
            next_state_index -= v

    print("shouldn't ever reach this")
    return chain


def get_transition_probability(chains,start_state,end_state,steps):
    """Gives the probability that you will reach end_state from start_state in steps,
        by sampling from the given list of chains."""
    instances = 0
    starting_subset = [chain for chain in chains if start_state in chain]
    for chain in starting_subset:
        if end_state in chain:
            start_ind = chain.index(start_state)
            if start_ind + steps < len(chain) and chain[chain.index(start_state) + steps] == end_state:
                instances += 1

    return instances/len(starting_subset)

if __name__ == '__main__':
    # if len(sys.argv) <= 2:
    #     print('Usage:\n\t-x:\tNumber of names to generate\n\t-n:\tNames source file\n\t-p:\tPlaces source file')
    #     return
    
    parser = argparse.ArgumentParser()
    parser.add_argument('-x','--amount', type=int, default=1, help='Number of names to generate')
    parser.add_argument('-n','--names', type=str, default='', help='Names source file')
    parser.add_argument('-p','--places', type=str, default='', help='Places source file')
    parser.add_argument('-t','--transition',
            nargs=3,
            default=(),
            metavar=('START_STATE','END_STATE','STEPS'),
            help='Probability that you will end in a given state starting from a different state in the specified number of steps')
    parser.add_argument('-q','--quiet', action='store_true', help='Suppress printing')
    parser.add_argument('-a','--average', action='store_true', help='Print average chain length')

    args = parser.parse_args()

    # generate options for each category using files if they exist
    names_lst = []
    places_lst = []
    if args.names:
        names_lst = read_options(str(args.names))
    if args.places:
        places_lst = read_options(str(args.places))
    categories,weights = generate_categories(names=names_lst,places=places_lst)

    # generate the names
    names = []
    chains = []
    start_state = 'names'
    num_names = int(args.amount)
    for _ in range(num_names):
        chains.append(transition([start_state],weights))
    for chain in chains:
        name = generate_name(chain,categories)
        names.append(name)
        if not args.quiet:
            print(name)

    if args.average:
        avg_chain_length = sum([len(chain) for chain in chains])/num_names
        print('\n\tAverage Chain Length: {}'.format(avg_chain_length))

    if args.transition:
        prob = get_transition_probability(chains,str(args.transition[0]),str(args.transition[1]),int(args.transition[2]))
        print('\n\tProbability of getting to "{}" starting from "{}" in {} steps: {}'.format(args.transition[1],args.transition[0],args.transition[2],prob))

